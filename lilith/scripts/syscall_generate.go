package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Syscall struct {
	name    string
	dstname string
	hasret  bool
	isnop   bool
	nargs   int
	islilith bool
}

var argRegister = []string{"rdi", "rsi", "rdx", "rcx", "r8", "r9"}

const debug = false

const syscallPrefix = "syscall_"
const syscallPtrPrefix = "*syscall_"
const lilithPrefix = "lilith_"

func main() {
	fh, err := os.Open("syscalls.c")
	must(err)
	defer fh.Close()
	s := bufio.NewScanner(fh)
	syscalls := []Syscall{}
	for s.Scan() {
		line := s.Text()
		if len(line) == 0 {
			continue
		}
		if line[0] == ' ' || line[0] == '\t' || line[0] == '#' {
			continue
		}
		v := strings.SplitN(line, " ", 2)
		if len(v) != 2 {
			continue
		}
		if !strings.HasPrefix(v[1], syscallPrefix) && !strings.HasPrefix(v[1], syscallPtrPrefix) && !strings.HasPrefix(v[1], lilithPrefix) {
			continue
		}
		if strings.HasPrefix(v[0], "//") {
			v[0] = v[0][2:]
		}

		fnret := strings.TrimSpace(v[0])
		v = strings.SplitN(v[1], "(", 2)
		if len(v) != 2 {
			continue
		}
		fnname := strings.TrimSpace(v[0])
		v = strings.SplitN(v[1], ")", 2)
		if len(v) != 2 {
			continue
		}
		fnargs := strings.TrimSpace(v[0])
		fnsuffix := strings.TrimSpace(v[1])

		if debug {
			fmt.Printf("[%s] [%s] [%s] [%s]\n", fnret, fnname, fnargs, fnsuffix)
		}

		s := funcToSyscall(fnret, fnname, fnargs, fnsuffix)

		if debug {
			fmt.Printf("\t%#v\n", s)
		}
		syscalls = append(syscalls, s)
	}
	must(s.Err())

	writeSyscallsTrampC(syscalls)
	writeSyscallsS(syscalls)
}

func funcToSyscall(fnret, fnname, fnargs, fnsuffix string) (s Syscall) {
	if fnret != "void" {
		s.hasret = true
	}
	if fnname[0] == '*' {
		s.hasret = true
	}

	const nopstr = "; NOP"
	if strings.HasSuffix(fnsuffix, nopstr) {
		s.isnop = true
		fnsuffix = fnsuffix[:len(fnsuffix)-len(nopstr)]
	}

	switch {
	case strings.HasPrefix(fnname, syscallPrefix):
		s.name = fnname[len(syscallPrefix):]
	case strings.HasPrefix(fnname, syscallPtrPrefix):
		s.name = fnname[len(syscallPtrPrefix):]
	case strings.HasPrefix(fnname, lilithPrefix):
		s.name = fnname[len(lilithPrefix):]
		s.islilith = true
	}

	s.dstname = s.name

	const comment = "//"
	if i := strings.Index(fnsuffix, comment); i >= 0 {
		s.dstname = strings.TrimSpace(fnsuffix[len(comment)+2:])
	}

	if fnargs != "void" {
		s.nargs = len(strings.Split(fnargs, ","))
	}

	return s
}

func (s Syscall) Prefix() string {
	if s.islilith {
		return "lilith"
	}
	return "syscall"
}

func writeSyscallsTrampC(syscalls []Syscall) {
	fh, err := os.Create("syscalls_tramp.c")
	must(err)
	w := bufio.NewWriter(fh)
	fmt.Fprintf(w, "// autogenerated file see scripts/syscall_generate.go\n")

	for _, s := range syscalls {
		fmt.Fprintf(w, "extern void asm_%s_%s(void);\n", s.Prefix(), s.name)
	}

	fmt.Fprintf(w, "void setup_syscall_trampolines(void) {\n")
	for _, s := range syscalls {
		if s.islilith {
			continue
		}
		fmt.Fprintf(w, "\ttrampoline_kernel_patch(NULL, %q, &asm_syscall_%s);\n", s.dstname, s.name)
	}
	fmt.Fprintf(w, "}\n")

	must(w.Flush())
	must(fh.Close())
}

func writeSyscallsS(syscalls []Syscall) {
	fh, err := os.Create("syscalls.s")
	must(err)
	w := bufio.NewWriter(fh)
	fmt.Fprintf(w, "// autogenerated file see scripts/syscall_generate.go\n")

	for _, s := range syscalls {
		fmt.Fprintf(w, "\t.text\n")
		fmt.Fprintf(w, "\t.globl asm_%s_%s\n", s.Prefix(), s.name)
		fmt.Fprintf(w, "\t.type asm_%s_%s, @function\n", s.Prefix(), s.name)
		fmt.Fprintf(w, "asm_%s_%s:\n", s.Prefix(), s.name)

		if s.isnop {
			fmt.Fprintf(w, "\t// don't do anything\n")
			if s.hasret {
				fmt.Fprintf(w, "\tmovq $0, %%rax\n")
			}
			s.writeRet(w)
			continue
		}

		if s.hasret {
			fmt.Fprintf(w, "\tpush_registers_except_rax\n")
		} else {
			fmt.Fprintf(w, "\tpush_registers\n")
		}

		for i := 0; i < s.nargs; i++ {
			if i >= len(argRegister) {
				fmt.Fprintf(w, "\tpushq %#x(%%rbp)\n", (i+2)*8)
			} else {
				fmt.Fprintf(w, "\tmovq %#x(%%rbp), %%%s\n", (i+2)*8, argRegister[i])
			}
		}
		fmt.Fprintf(w, "\tcall %s_%s\n", s.Prefix(), s.name)

		if s.nargs > len(argRegister) {
			fmt.Fprintf(w, "\taddq $%#x, %%rsp\n", (s.nargs-len(argRegister))*8)
		}

		if s.hasret {
			fmt.Fprintf(w, "\tpop_registers_except_rax\n")
		} else {
			fmt.Fprintf(w, "\tpop_registers\n")
		}

		s.writeRet(w)
	}

	must(w.Flush())
	must(fh.Close())
}

func (s *Syscall) writeRet(w io.Writer) {
	if s.nargs == 0 {
		fmt.Fprintf(w, "\tret\n\n")
		return
	}
	fmt.Fprintf(w, "\tret $%#x\n\n", s.nargs*8)
}
